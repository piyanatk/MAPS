/************************************************************************/
/*                                                                      */
/* read_array_spec.c                                                    */
/*                                                                      */
/* Parses a text file containing stations and antenna locations and     */
/* properties, into an array_specification struct.                      */
/*                                                                      */
/*      Inputs:     filename        Generated by some other program     */
/*                                                                      */
/*      Output:     arrayspec       Filled in struct                    */
/*                  return value    0=OK, else bad                      */
/*                                                                      */
/* Created  6 Feb 2002 by CJL                                           */
/* Modified 09 Dec 2010 by L. Benkevitch                                */
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include <math.h>
#include <string.h>
#include "array_specification.h"

#define EARTH_RAD 6378140.0 /* radius of Earth in meters */
#define LINE_LEN 256
#define FALSE 0
#define TRUE 1

/* in this file, the E,N,H offsets are in a local cartesian 
 * coord system. Rotations to array center lat/long
 * are for this fixed cartesian coords and therefore do not 
 * follow any Earth curvature and such. */

int
read_array_spec (char *filename,
		 char *layoutdir,
		 struct array_specification *arrayspec)
{
    double dx=0, dy=0, dz=0.0, r, r_meters, sin_lat, sin_dlong;
    double latitude, longitude, X0, Y0, Z0, X, Y, Z;
    int nst, n, i,num_pols=0,nfield=0;
    char line[LINE_LEN], templine[LINE_LEN], stlayout[MAX_LNAME_SIZE],
      stname[MAX_LNAME_SIZE], keywd[LINE_LEN];
    struct stationspec *stn;
    FILE *fp;
    double ph, th, cosph, sinph, costh, sinth;
    const double pi = 3.1414926, radeg = 180./pi;
    double *x, *y, *z, *x1, *y1;

    /* defaults */
    arrayspec->num_pols = 1;
    arrayspec->vlbi = FALSE;
    nst = 0;

    for (i=0; i<MAX_STATIONS; i++) {
      stn = arrayspec->station + i;
      stn->north_offset = stn->east_offset = stn->height_offset =0.0;
      stn->longitude = stn->latitude = 0.0;
      stn->x_coord = stn->y_coord = stn->z_coord = 0.0;
      stn->layout = NULL;
      stn->low_el_limit = stn->sumweight = stn->sefd = 0.0;
      stn->high_el_limit = (M_PI/2.0);
    }
    /* Open array specification file */
    if ((fp = fopen (filename, "r")) == NULL) {
        msg ("Unable to open array spec file '%s'", 2, filename);
        return (1);
    }
                                        // Loop over lines, 1 per station
    while (fgets (line, LINE_LEN, fp) != NULL) {
        if (line[0] == '*') continue;
        if (line[0] == '#') continue;
        rm_whitespace (line);
        if (strlen (line) == 0) continue;
        nfield=1;                // How many fields in line
        strncpy(templine,line,LINE_LEN);
        strtok(templine," \t");
        while (strtok(NULL," \t") != NULL) {
            nfield++;
        }
        stn = arrayspec->station + nst;
        stn->st_id = nst;
        
        if (nfield > 3) {
          /* The antenna coordinates are Cartesian (x,y,z) where
	   * the origin (0,0,0) is the center of earth.
	   * The coordinates of VLBI antennae can only be specified 
	   * this way.
	   */
          float low_el = 0.0, high_el = 90.0, sefd = 0.0;
      
          sscanf (line, "%s %lf %lf %lf %s %f %f %f", stname, &dx, &dy, &dz, 
		  stlayout, &low_el, &high_el,&sefd);
          if (sefd > 0.0) stn->sefd = sefd;
          if (low_el > 0.0) stn->low_el_limit = low_el*(M_PI/180.0);
          if (high_el > 0.0) stn->high_el_limit = high_el*(M_PI/180.0);
          stn->x_coord = dx;
          stn->y_coord = dy;
          stn->z_coord = dz;
          stn->longitude = atan2(dy,dx);
          stn->latitude = asin(dz/sqrt(dx*dx+dy*dy+dz*dz));
          msg("Station %d, %s\t%.1lf,%.1lf,%.1lf\tstation: %s El lims "\
	      "(radian): %.3f,%.3f Geocentric lat/long (radian): %.3lf %.3lf",
	      1, nst, stname, stn->x_coord, stn->y_coord, stn->z_coord, 
	      stlayout,stn->low_el_limit,
	      stn->high_el_limit,stn->latitude,stn->longitude);
        }
        else if (nfield == 3) {
          /* old-style */
	  /* The antenna coordinates are given in a local Cartesian system
	   * as east and north offsets with respect to the array center
	   */
          n = sscanf (line, "%lf %lf %s", &dx, &dy, stlayout);
          /* if (n != 3) { */
          /*   msg ("Invalid line '%s', '%s'", 2, filename, line); */
          /*   return (1); */
          /* } */
      
          // Store raw input coordinates
          /* currently we do not have height offsets in the 
	   * input files, but this will work if they are added later */
          stn->north_offset = dy;
          stn->east_offset = dx;
          stn->height_offset = dz;
      
          // Convert to radial coordinates
          r_meters = sqrt (dx*dx + dy*dy);
          r = r_meters / EARTH_RAD;
          th = atan2 (dx, dy);
          /* Spherical trig to get station lat/long */
          sin_lat = sin (arrayspec->location.lat_radian) * cos (r) +
                    cos (arrayspec->location.lat_radian) * sin (r) * cos (th);
          latitude = asin (sin_lat);
          sin_dlong = sin (r) * sin (th) / cos (latitude);
      
          longitude = arrayspec->location.lon_radian + asin (sin_dlong);
          stn->longitude = longitude;
          stn->latitude = latitude;
      
          /* ENH calculated for a specific latitude, so the
           * transformation to XYZ must also be performed 
	   * at a single latitude. Some of these parameters
           * may already be defined. */
      
          // Calculate the array centre in local XYZ coordinates.
          X0 = EARTH_RAD*cos(arrayspec->location.lon_radian)* 
	    cos (arrayspec->location.lat_radian);
          Y0 = EARTH_RAD*sin(arrayspec->location.lon_radian)* 
	    cos (arrayspec->location.lat_radian);
          Z0 = EARTH_RAD*sin(arrayspec->location.lat_radian);
      
          // Calculate the antenna locations in local XYZ
	  // coordinates (add height terms if dh is specified).
          X  = X0 - dy*sin(arrayspec->location.lat_radian) + 
	    dz*cos(arrayspec->location.lat_radian);
          Y  = Y0 + dx;
          Z  = Z0 + dy*cos(arrayspec->location.lat_radian) + 
	    dz*sin(arrayspec->location.lat_radian);
      
          // Rotate the antenna locations to the Greenwich meridian.
          stn->x_coord = Y*sin(-arrayspec->location.lon_radian) + 
	    X*cos(-arrayspec->location.lon_radian);
          stn->y_coord = Y*cos(-arrayspec->location.lon_radian) - 
	    X*sin(-arrayspec->location.lon_radian);
          stn->z_coord = Z;
          msg("Station %d, x,y,z: (%.10g,%.10g,%.10g), layout: %s",
	      -1, nst, stn->x_coord, stn->y_coord, stn->z_coord,
          stlayout);
      
        }
	else if (nfield == 1) { /* May be only one word 'VLBA' */
	/*
	 * Read the 'VLBI' word. Present or absent, 
	 * it has lower priority than
	 * the -l (localized) and -v (VLBI, global) cmd line option.
	 * Added by L. Benkevitch, 09-Dec-2010 
	 */
	  n = sscanf (line, "%4s", keywd);
	  for (i = 0; i < 4; i++) keywd[i] = toupper((int)keywd[i]);
	  printf("%s\n", keywd);
	  if (strcmp(keywd, "VLBI") == 0) {
	    arrayspec->vlbi = TRUE;
	  }
	}
        /* Fetch specified station layout */
        stn->layout = get_stn_layout(layoutdir,stlayout);
        
        if (stn->layout == NULL) {
            msg ("Cannot find station layout '%s'", 2, stlayout);
            return (1);
        }

        /* sanity check: check that all stations are 
	 * either single or dual pol. no mixtures */
        if (num_pols != 0 && num_pols!=stn->layout->ants[0].num_receptors) {
            msg("ERROR: mixed polarisation types between stations. "\
		"Must be all single or all dual pol",2);
            return -1;
        }
        num_pols = stn->layout->ants[0].num_receptors;
        
        nst++;
    }

    fclose(fp);
    arrayspec->nst = nst;
    arrayspec->num_pols = num_pols;
 
    /*
     * For the "new style" station files
     * Convert the (x,y,z) into  (east_offset, north_offset)
     * with respect to the array center, calculated as
     * the array centroid projection on the earth surface
     * Added by L. Benkevitch, 07-Dec-2010
     */
    if (nfield > 3) {
      msg("The array east and north offsets are calculated " \
	  "with respect to the array centroid", 0); 
      X0 = Y0 = Z0 = 0;
      /* The array centroid coordinates */
      for (i = 0; i < nst; i++) {
	X0 += arrayspec->station[i].x_coord;
	Y0 += arrayspec->station[i].y_coord;
	Z0 += arrayspec->station[i].z_coord;
      }
      X0 = X0/(double)nst;
      Y0 = Y0/(double)nst;
      Z0 = Z0/(double)nst;
      /* printf("X0, Y0, Z0 = %12.4e %12.4e %12.4e\n", X0, Y0, Z0);  */
      /* Spherical coordinates (ph,th) of the array centroid */
      ph = atan2(Y0, X0);
      th = atan2(sqrt(pow(X0,2) + pow(Y0,2)), Z0);
      /* Rotations to make the array centroid lie on the Z axis
       * First, rotate XY ccw by ph. Second, rotate ZX cw by th.
       * After this transformation, east_offset and north_offset
       * are the projections of x and y on tangent plane.
       */
      /* fp = fopen ("array_coords.txt", "w"); */
      cosph = cos(ph);
      sinph = sin(ph);
      costh = cos(th);
      sinth = sin(th);
      msg("The array east and north offsets are aclculated " \
	  "with respect to the array centroid", 0); 
      msg("Array centroid colatitude and longitude: th, ph = %g, %g (deg)\n", 
	  0, th*radeg, ph*radeg); 
      msg("cos(ph), sin(ph) = %g, %g\n", cosph, sinph); 
      printf("cos(th), sin(th) = %g, %g\n", costh, sinth); 
      for (i = 0; i < nst; i++) {
	x =  &arrayspec->station[i].x_coord;
	y =  &arrayspec->station[i].y_coord;
	z =  &arrayspec->station[i].z_coord;
	x1 = &arrayspec->station[i].east_offset;
	y1 = &arrayspec->station[i].north_offset;
	*x1 =   (*x)*cosph + (*y)*sinph;
	*y1 =  -(*x)*sinph + (*y)*cosph; /* North is opposite to  Y */
	*x1 = (*x1)*costh - (*z)*sinth;  /* East is in direction of X */
	/* printf("%12.4e %12.4e %12.4e %12.4e %12.4e %g\n",  */
	/*        *x, *y, *z, *x1, *y1, sqrt(pow(*x1,2) + pow(*y1,2))); */
	/* fprintf(fp, "%12.4e %12.4e %12.4e %12.4e %12.4e\n",  */
	/* 	arrayspec->station[i].x_coord, */
	/* 	arrayspec->station[i].y_coord, */
	/* 	arrayspec->station[i].z_coord, */
	/* 	arrayspec->station[i].east_offset, */
	/* 	arrayspec->station[i].north_offset); */
      }
      /* fclose(fp); */
    }

   
    /* printf(" X0, Y0, Z0 = %g, %g, %g\n", X0, Y0, Z0); */
    /* printf("lat, lon = %g %g\n", arrayspec->location.lat_radian,  */
    /* 	   arrayspec->location.lon_radian); */

    return (0);
}
