\documentclass[letterpaper, oneside, 11pt]{article}
%\documentclass[letterpaper, twoside, 12pt]{article}
\usepackage{amsmath}
\setlength{\parindent}{0.0in} % Force zero paragraf indentation
%\title{MASSACHUSETTS INSTITUTE OF TECHNOLOGY (HAYSTACK OBSERVATORY)}
\title{VISGEN: Radio Telescope Array Observation Simulator}

\author{Leonid Benkevitch}

\begin{document}

\centerline{\large\bf MASSACHUSETTS INSTITUTE OF TECHNOLOGY}
\centerline{\large\bf HAYSTACK OBSERVATORY}
\smallskip
\centerline{\normalsize Westford, Massachusetts 01886}
\bigskip
\centerline{February 24, 2011}
\bigskip
\bigskip
\bigskip
\centerline{\LARGE\bf VISGEN: Radio Telescope Array}
\centerline{\LARGE\bf Observation Simulator}

%\maketitle

\begin{abstract}
The program {\tt visgen} is the main part of the MAPS (MIT Array Performance Simulator) package. On input, it reads a visibility file prepared by {\tt MAPS\_im2uv} program, a file of radio telescope array specifications, and parameters of observation to produce a simulated visibility image as if it were a result of real observation with the specified array. Further processing requires {\tt maps2uvfits} program to convert the native {\tt visgen} visibility format into the standard {\tt uvfits} file, which is readable by {\tt AIPS} or {\tt MIRIAD} packages. 

This document is not a complete {\tt visgen} description. It rather documents recent improvements and bug fixes based on the buglist and private communications with the {\tt MAP} users and developers. 
\end{abstract}

\section{{\tt VISGEN} Command line options}

\begin{tabbing}
Usage: {\tt visgen [options]} \\
\\
{\tt -n name}  \hspace{5mm} \= name of the simulation \\
{\tt -s name}  \>name of the site \\
{\tt -A name}  \>name of file with the array definition \\
                      \>(station types and locations) \\
{\tt -G name}  \>name of a UV grid data file \\
                    \>If multiple input polarisations are required \\
                    \>specify multiple -G options. \\
                    \>Assumed order is I,Q,U,V \\
{\tt -M name}  \>name of a metafile listing gridfiles \\
                 \>Format: pol identifier [I,Q,U or V] and filename per line \\
                 \>[over-rides -G options] \\
{\tt -V name}  \>name of the observation specification file \\
{\tt -N}       \>do not add noise \\
{\tt -S SEFD}  \>set global station system equivalent flux density.  \\
		      \>Default: 500 \\
{\tt -Z}       \>do not compute visibilities from UV grid data \\
		      \>(does not apply to oob) \\
{\tt -a}       \>turn on accounting \\
{\tt -I name}  \>name of the ionospheric model file. Turns on ionospheric \\
		      \>modelling \\
{\tt -i name}  \>name of the ionospheric settings file. Default: \\
	       \> \$TEXTDIR/iono\_settings.txt \\
{\tt -O name}  \>include 'out-of-beam' (oob) sources listed in file 'name' \\
{\tt -R name}  \>name of the RFI model file. Turns on RFI modelling \\
		      \>(currently not implemented) \\
{\tt -m num}   \>turn debugging output to level num. \\
		      \>(-2 lots thru 2 little) \\
{\tt -l}    \>treat the array as localized (non-VLBI). Only the baselines \\
		   \> formed by the most remote stations are checked before the \\
		   \>actual simulation. \\
{\tt -v}     \>treat the array as global (VLBI). All the baselines are \\
		   \> checked before the actual simulation. \\
{\tt -D [IOMBN]} \>turn on module-level dubugging (copious output) for one \\
	\> or many modules: \\
        \>         {\tt I} ionosphere \\
        \>         {\tt O} oob \\
        \>         {\tt M} makebeam \\
        \>         {\tt B} compute\_beamconvl \\
        \>         {\tt N} add\_noise \\
\end{tabbing}

\section{Brief description of {\tt visgen} operation}

The visgen program allows to ``look'' at the sky with a radio relescope or radio interferometer which consists of a number of receivers (an ``array''), scattered over an area on the surface of the earth, or even distributed globally, as in case with the Very Large Baseline Array, or VLBI, array. The output of {\tt visgen} is the image that the array can ``see''. At the moment of simulation the array may not exist, being at the stage of development or prototyping, thus {\tt visgen} can provide valuable information related to the characteristics of the finished array design. \\

On input {\tt visgen} requires the following information (the corresponding command line options are given for each item):
\begin{itemize}
 \item Names of the simulation (option {\tt-n}) and the site (option {\tt-s});
 \item The ``ideal'' sky image: the UV-grid data file generated by {\tt MAPS\_im2uv} program, option -G;
 \item The coordinates of array receiver stations (dishes, tiles, frames etc.), option {\tt-A};
 \item Parameters of each station (no option; obtained from array specification file);
 \item Specifications of the observation (RA, DEC, frequency, time, duration etc., in ``obs\_spec'' file), opton {\tt -V}. 
\end{itemize}
There are also a few optional files that may be required dependent on the observation:
\begin{itemize}
 \item File describing the out-of-beam sources, option {\tt-O};
 \item Files specifying the ionospheric parameters, option {\tt-I};
 \item The metafile listing UV-gridfiles for the case of several polarizations, option {\tt-M}.
\end{itemize}

The {\tt visgen} output is a file in native format containing the visibilities calculated over all the possible baselines of the array. Its name is not specified on the command line, and it is generated automatically as $<$simulation name$>$.vis. Typically, the similar observational data are acquired during real operation of the radio telescopes and interferometers.\\

Roughly, {\tt visgen} operation is implemented as five nested loops, indicated below in the order of increasing depth:
\begin{itemize}
 \item Loop over scans. An observation can include several scans, differing by frequencies, celestial coordinates, or integration parameters.
 \item Loop over integration time slices. 
 \item Loop over baselines. Consists of two nested loops, bringing up all the possible baselines between the station pairs.
 \item Loop over observing frequency IFs. 
 \item Loop over correlator frequency channels within an IF.
\end{itemize}

In the course of simulation {\tt visgen} samples the visibility data from the $uv$-plane, provided by the {\tt MAPS\_im2uv} program, in the form of patches. The patch is located roughly at $(u,v)$, where $u \le (x_2 - x_1)/\lambda$, and  $v \le (y_2 - y_1)/\lambda$. Here $x$ and $y$ are coordinates of two stations, $(x_2 - x_1)$ and $(y_2 - y_1)$ determine the baseline length, and $\lambda$ is the wavelength. Clearly, $(u,v)$ must be within the $uv$ grid, otherwise the simulation fails. The patch size is determined by the frequency bandwidth and the integration time, and the patch must also fit in the $uv$-grid, otherwise the simulation cannot continue. Simulations with high resolution images and arrays with large numbers of stations can require a significant amount of computing time, from hours to days, and a baseline or patch failure can happen when a significant time has already been spent. To avoid this, it is necessary to check if all the baselines and patches fit in the $uv$-grid before the simulation starts. This check has been implemented in the current version of {\tt visgen}.


\section{Latest improvements to {\tt visgen}}

\subsection{Preliminary baseline checking}

In order to check if all the baselines and patches fit in the $uv$-plane \emph{before} the simulation starts, {\tt visgen} launches a new subroutine, {\tt check\_baseline()}, which is actually a ``mini-{\tt visgen}'' in the sense that it reproduces all the {\tt visgen} operations for the baseline and patch generation and checking, but makes neither disk memory access nor integrations. The time needed for such a ``dry run'' is order(s) of magnitude less than that required for an actual simulation. However, in the case of arrays with large number of stations the number of baselines and patches is big enough to take several minutes to complete the check. \\

A good example is the SKA array with planned 2400 stations. Simple calculation gives the number of baselines to be analysed at $2400(2400-1)/2 = 2,878,800$. \\

\subsection{Array convex hull computation}

We have implemented a technique that dramatically reduces the number of the analysed baselines. Not all the baselines deserve testing, but only the longest. The longest baselines are produced by the most remote from each other station pairs, i.e. the stations located on the periphery of the array. We define the array periphery as the convex hull of all the stations considered as a set of points on the earth surface. In the case of localized (non-VLBI) arrays the earth surface can be approximated by a plane. The convex hull of a set of points can be defined as the minimal polygon whose vertices are the the points belonging to the set, and all the other non-vertex points belong to this polygon's interior. \\

After some analysis of the published convex hull algorithms we designed our own algorithm and implemented it in the C language as the subroutine {\tt convex\_hull\_2d()} in the file {\tt \$SIM/visgen/convex\_hull\_2d.c}. The algorithm is very efficient. Its speed is apparently at the level $O(n\ln n)$ or even better (however, it still needs to be proven mathematically). The algorithm {\tt convex\_hull\_2d()} uses ring lists, the list structures closed into ring, so that the last atom in such a list points at its first atom. The primitives for list creating, deleting, inserting, copying and printing are saved in the file {\tt visgen/list\_proc.c}. The lists are utilized to store indices of the points that are the poligon vertices. In a few steps the points belonging to the set of convex hull vertices are found and inserted into the vertex list.\\

The convex hull vertex indices of the analyzed array and the array $(east,north)$ coordinates are stored in the files {\tt bd\_idx.txt} and {\tt points.txt}. To visualize the array and its convex hull a simple python script, {\tt plot\_hull.py}, has been written and stored in the {\tt \$SIM/visgen/scripts} directory. To use it, install the packages {\tt matplotlib} and {\tt ipython}. After {\tt visgen}, simply run \\

{\tt\$ plot\_hull.py} \\

to open the window with the view of array and its minimal polygon. For example, for the SKA array it shows that the whole array lies inside of the minimal poligon with 11 vertices. Therefore, for only 11 of 2400 stations the baselines are to be analyzed, or just $12*11 = 132$ baselines of the total of 2,878,800. This takes a split of a second. \\

Note that the convex-hull technique cannot be used if the array stations are globally distributed as in the VLBI case. Therefore, for the VLBI arrays \emph{all} the baselines are analyzed. \\

\subsection{``Old`` and ``new`` styles of array coordinates}

The array convex hull calculation required to make the array coordinate input more consistent in the subroutine {\tt \$SIM/visgen/read\_array\_spec.c}. Now, undependent of ``old style'' $(east,west)$ and ``new style'' $(x,y,z)$ of the station coordinates specification, both representations are stored in the stricture {\tt struct array\_specification arrayspec}. If the array coordinates in an array specification file from the directory {\tt \$SIM/array/} are given in the form of global Cartesian triplets $(x,y,z)$, they are recalculated into the local $(east,north)$ coordinates relative to the projection of the array \emph{centroid} on the earth surface. \\
  
\subsection{Distinguishing VLBI and localized arrays}

In the new {\tt visgen} version a global VLBI flag has been introduced. Now the array is treated as VLBI or non-VLBI independently of the ``old-style'' or ``new-style'' station coordinate specifications. Two levels of the VLBI indication exist:
\begin{itemize}
 \item VLBI line in the array specification file in directory {\tt \$SIM/array/};
 \item the command line options {\tt -v} and {\tt -l} (higher priority).
\end{itemize}
To specify the array as globally distributed, insert line with the VLBI (or vlbi) word at the beginning of the array specification file. If there a no {\tt -v} or {\tt -l} options in the {\tt visgen} command line, the array is processed as the VLBI or global array. \\

The command line option {\tt -l} has higher priority: it will make {\tt visgen} treat the array as localized, and it will suppress the VLBI line action. \emph{Vice versa}, the presence of command line option {\tt -v} makes {\tt visgen} treat the array as localized, or non-VLBI. \\ 

The only difference in processing VLBI and non-VLBI arrays in the new {\tt visgen} version  is in the baseline checking. For the VLBI, or global, arrays the array convex hull is not calculated, therefore all the baselines are analysed before the simulation. Thus, to check not only the baselines for the peripheral stations, but all the possible baselines, simply add option {\tt -v} to the command line. \\

\subsection{Diagnostics and recommendations}

If a specific simulation did not pass the baseline check, {\tt visgen} issues the recommendations how to correct the conditions for the simulation could be continued. A particular example of the diagnostics and recommendations is shown below: 
\begin{tabbing}
{\tt CHECK\_BASELINE: 11 bad baselines found} \\
{\tt CHECK\_BASELINE: umin\_len, umax\_len =   -230157    107140 (meters)}\\
{\tt CHECK\_BASELINE: vmin\_len, vmax\_len =   -277383    -28364 (meters)}\\
{\tt CHECK\_BASELINE: umin, umax =      -107493        50039 (wl, at 140.016 MHz)}\\
{\tt CHECK\_BASELINE: vmin, vmax =      -129550     -13247.2 (wl, at 140.016 MHz)}\\
{\tt CHECK\_BASELINE: Absolute maximum dimensions along u or v:} \\
\hspace{35mm} \={\tt uvmax = 129549 (wavelenghts)}\\
{\tt CHECK\_BASELINE: The longest baseline is 136363 (wavelengths)}\\
{\tt CHECK\_BASELINE: The array resolution is 7.33336e-06 (radians) }\\
\>{\tt or 0.000420184 (degrees) at frequency 140.112 MHz}\\
{\tt CHECK\_BASELINE:  }\\
{\tt CHECK\_BASELINE: Recommendations:}\\
{\tt CHECK\_BASELINE: In order to continue simulation with this array,}\\
{\tt CHECK\_BASELINE: EITHER increase the patameter 'Visibility grid x-log2N'}\\
\>{\tt in file}\\
{\tt CHECK\_BASELINE: 'test01\_Description.txt' from current 10 to 11, }\\
{\tt CHECK\_BASELINE: and then run LOsim and MAPS\_im2uv programs, }\\
{\tt CHECK\_BASELINE: OR decrease the parameters FOV\_size in file }\\
{\tt CHECK\_BASELINE: 'obs\_spec\_test01\_gha' from current 1000 down}\\
\>{\tt to 815.22 (arcseconds) or less.}\\
\end{tabbing}


\section{How to try the new version}

The improved versions of the MAPS package are currently being contained in a repository separate from that of the standard MAPS. To try the new version, we recommend the following sequence.
\begin{enumerate}
 \item Install the packages {\tt matplotlib} and {\tt ipython} using the means of your operating system. \\
 \item Temporarily rename your working copy (we assume it has the name MAPS; otherwise use your own name):\\
{\tt \$ mv MAPS MAPS\_orig} \\
 \item Checkout the new version from the repository: \\
{\tt \$svn checkout svn+ssh://mwa-lfd.haystack.mit.edu/svn/MAPS2/mapscorr MAPS}\\
 \item Try to run your tasks and see the output. We also recommend to try the {test01} on the SKA variant with 1964 antennae:
\begin{tabbing}
{\tt \$ cd MAPS/test/test01} \\
{\tt \$ LOsim test01 > /dev/null} \\
{\tt \$ MAPS\_im2uv -i test01\_Brightness.fts -o test01\_Visibility.dat  \textbackslash }\\ 
\hspace{15mm} \={\tt -n 0.0304617} \\
{\tt \$ visgen -n test01 -s SKA\_1 \textbackslash} \\ 
\>{\tt -A \$SIM/array/ska1964\_star\_clumps.txt \textbackslash} \\
\>{\tt -G test01\_Visibility.dat -V obs\_spec\_test01\_gha -N -m 0}
\end{tabbing}
 \item {\tt Visualize the array and its convex hull:} \\
{\tt \$ plot\_hull.py} \\
 \item After you have finished testing the new MAPS version, remove it: \\
{\tt \$ rm -fr MAPS} \\
 \item Restore your MAPS version: \\
{\tt \$ mv MAPS\_orig MAPS}
\end{enumerate}

\end{document}






